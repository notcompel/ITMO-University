## Second chance
Это алгоритм из класса политик, применяемых для управления страницами виртуальной памяти.

Кеш задан очередью FIFO, где у каждого элемента помимо кешируемого значения есть признак используемости. При добавлении нового элемента, он добавляется в начало очереди, возможно вызывая вытеснение элемента с конца очереди. Признак используемости у вновь добавленного элемента не выставлен.

При вытеснении элемента у него проверяется признак используемости и если он выставлен, то элемент не удаляется совсем, а помещается в начало очереди (возможно также вызывая новое вытеснение), при этом признак используемости этого элемента сбрасывается.

Возврат вытесненного, но "спасённого" признаком используемости элемента в очередь происходит _до_ помещения туда нового элемента, чья вставка вызвала
вытеснение.
Таким образом, вновь вставленный в кеш элемент всегда будет в начале очереди, а все изменения, связанные с вытеснением и возможным возвратом в очередь будут
происходить до его вставки (но с очередью, чей эффективный размер на единицу меньше размера кеша).

Возможно, что в очередь все элементы имеют признак используемости - тогда добавление нового элемента и вытеснение одного из старых элементов:
* сбросит все признаки используемости
* удалит из кеша элемент из конца очереди

При поиске элемента, если он найден, то он не меняет своей позиции в очереди, но у него выставляется признак используемости.

### Допущение в реализации
В реализации кеша допустимо предполагать, что все хранимые там объекты имеют в иерархии наследования предка, задаваемого шаблонным параметром KeyProvider,
который, в свою очередь, имеет оператор равенства с ключом (задаваемым шаблонным параметром Key).

## Модификация pool аллокатора с поддержкой нескольких типов объектов

Требуется расширить реализацию pool аллокатора возможностью размещать объекты нескольких разных типов (разного размера).
Возможны разные подходы к реализации такой идеи, но мы остановимся на варианте, напоминающем упрощённую модель [SLAB
аллокатора](https://en.wikipedia.org/wiki/Slab_allocation):
* пул состоит из набора блоков (slab)
* каждый блок используется для выделения памяти для объектов одного размера
* все блоки имеют одинаковый размер, указываемый при создании пула
* если в блоке кончается место, то попытка выделения памяти под объект соответствующего размера завершается неудачей

Пул должен создаваться с параметрами "размер блока" и "список размеров объектов". К расходу памяти предъявляются следующие требования:
* пусть пул создан с `N` блоков
* пусть размер блока равен `K`
* пусть размер элемента `i` блока равен `S(i)`
* тогда максимальный расход памяти на пул должен составлять `M <= N * (K + 8 * sizeof(void *)) + 10 * sizeof(void *) * sum(K / S(i) for i in range(N))`

Память под объект должна выделяться в блоке, выделенном для размера такого объекта.

Очевидно, что основным преимуществом такой схемы (в рамках задач выделения памяти под объекты разного размера) является отсутствие фрагментации. Основным
недостатком является негибкое выделение памяти - если разные размеры имеют разную частоту использования, то какие-то блоки могут простаивать с малой заполненностью.
Кроме того, если какой-то размер объектов не делит размер блока нацело, то часть памяти будет теряться впустую.
В более реалистичных реализациях блоки скорее всего будут выделяться динамически - когда один блок полностью заполнен, то запрос на выделение памяти под объект
соответствующего размера будет вызывать создание нового блока для обслуживания этого размера.

Подумайте, как можно оптимизировать служебные расходы памяти в таком аллокаторе и как ограничения стандарта языка мешают этой задаче. Можно ли обойти эти помехи,
если слегка пожертвовать универсальностью аллокатора?
